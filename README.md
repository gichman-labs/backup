# Домашнее задание к занятию "`Резервное копирование`" - `Oleg Avvakumov`

---

### Задание 1

`Кейс
Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования.

Необходимо описать, какие варианты резервного копирования подходят в случаях:

1.1. Необходимо восстанавливать данные в полном объёме за предыдущий день.

1.2. Необходимо восстанавливать данные за час до предполагаемой поломки.

1.3.* Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.

Приведите ответ в свободной форме.`

### Ответ

'1.1. Нужно восстанавливать данные в полном объёме за предыдущий день.

Самый прямой вариант — ежедневный полный бэкап (Full backup), например ночью.
Почему подходит: полный бэкап — это копия всего набора данных, и его удобно/быстро восстанавливать, потому что зависимость только от одной копии.
Раз в сутки делаем Full backup (холодный или горячий — по требованиям простоя).
Если “упало” — разворачиваем вчерашний full и получаем состояние “на конец вчерашнего дня”.

1.2. Нужно восстановиться за час до предполагаемой поломки

Вариант A: 
Full + инкрементальные бэкапы, например каждый час
Инкрементальные бэкапы копируют только изменившиеся блоки с момента последнего задания, поэтому можно делать много “точек восстановления” (хоть каждый час).
Минус: восстановление дольше — нужно поднять full и “накатить” цепочку инкрементов.

Схема:
Раз в сутки/неделю — Full.
Каждый час — Incremental.
При аварии — restore full + инкременты до точки “за 1 час до сбоя”.


Вариант B (для PostgreSQL): 
Base backup + WAL (PITR)
В PostgreSQL можно восстановиться “к нужному моменту”, если есть базовая копия и архив WAL: восстановили файлы и “проиграли” WAL до нужного времени,
физический бэкап с Point-in-Time Recovery, где точка восстановления может быть “в любой момент”.

Схема:
Делаем base backup.
Постоянно архивируем WAL.
Восстанавливаемся на время "T − 1"


1.3. Возможен ли кейс “моментального переключения” на работающую/починенную БД?

Да, это уже про высокую доступность (High Availability): репликация + failover (мастер/реплики).  При падении источника одна из реплик может быстро взять роль источника, минимизируя простой. При крахе мастера можно оперативно назначить новым мастером один из слейвов и перенаправить клиентов. Важная оговорка: репликация — не замена резервному копированию, потому что она про доступность/аварийное восстановление, а не про “откат назад” при логической порче данных. То есть в “идеальном” проде делают и репликацию для мгновенного переключения, и обычные бэкапы для гарантированного восстановления/отката.'
---

### Задание 2

`Задание 2. PostgreSQL
2.1. С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).
2.1.* Возможно ли автоматизировать этот процесс? Если да, то как?
Приведите ответ в свободной форме.`

### Ответ

'2.1. Пример команд резервного копирования и восстановления (pg_dump / pg_restore)

Вариант A — дамп в SQL-файл (plain)

Сделать бэкап:

pg_dump dbname > dump.sql

Восстановить обратно:

psql -X dbname < dump.sql

Смысл: pg_dump выгружает базу в текстовый SQL (таблицы, данные, индексы и т.д.), а psql этот SQL “проигрывает” и восстанавливает.

Вариант B — дамп в архивный формат (custom) + pg_restore

Этот вариант удобнее для реальной жизни, потому что архив можно восстанавливать гибче (например, чистить объекты перед восстановлением, выбирать что восстанавливать и т.п.).

Сделать бэкап в custom-формат:

pg_dump -F c -f backup.dump dbname

Восстановить:

createdb -T template0 dbname_restore

pg_restore -d dbname_restore --clean --if-exists backup.dump

--clean — перед восстановлением делает DROP объектов (то есть “перезаливает” базу).

--if-exists — чтобы при --clean не ругалось, если чего-то нет.


2.1.* Можно ли автоматизировать? Да

Да, это обычно автоматизируют так:
Пишем простой скрипт (bash/батник), который:
делает pg_dump в файл с датой в названии (например backup_2026-01-15.dump),
при желании сжимает, удаляет старые копии (например, старше 7/14/30 дней),
пишет лог (успешно/ошибка).
Ставим запуск по расписанию:
на Linux — cron или systemd timer,
на Windows — “Планировщик заданий”.
Чтобы не вводить пароль руками, используют:
файл .pgpass (нормальный вариант для автозапуска),
либо переменные окружения, но это хуже по безопасности.
В итоге бэкапы делаются сами по расписанию, а ты только контролируешь, что файлы реально создаются и периодически проверяешь восстановление тестом.
'

---

### Задание 3

`3.1. С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL.
3.1.* В каких случаях использование реплики будет давать преимущество по сравнению с обычным резервным копированием?
Приведите ответ в свободной форме.`

### Ответ

'3.1. Пример команды инкрементного бэкапа MySQL

В MySQL инкрементный бэкап чаще всего делают через бинарные логи (binlog):
делаем полный бэкап, а потом сохраняем только изменения, которые накопились в binlog после него.
Чтобы “отрезать” очередной инкремент, в документации рекомендуют провернуть (rotate) логи командой FLUSH LOGS, и после этого копировать нужные binlog-файлы:

mysql -u root -p -e "FLUSH LOGS;"

Дальше сами binlog можно забрать утилитой mysqlbinlog. Пример из официальной документации (скачать binlog с сервера “как есть”):

mysqlbinlog --read-from-remote-server --host=host_name --raw binlog.000130 binlog.000131

То есть логика такая: полная копия = база, а binlog = инкрементальные изменения за период.

3.1.* Когда реплика лучше, чем обычные бэкапы?

Реплика даёт преимущества, когда важны доступность и быстрый “подъём” после аварии, а не просто “иметь архив на всякий случай”.
Быстро продолжить работу при падении мастера
Если основной сервер умер, можно относительно быстро переключиться на реплику (failover) и минимизировать простой.
Разгрузка основного сервера
На реплику можно увести тяжёлые SELECT-запросы, отчёты, аналитику, чтобы не тормозить прод.
Удобно делать бэкапы не с мастера
Официально рекомендуют: если бэкап грузит основной сервер, можно делать бэкап на реплике, чтобы не мешать рабочей базе.
Но важно: реплика не заменяет бэкап.
Если кто-то случайно удалит данные или “сломает” их логически, это может улететь на реплику тоже. Поэтому нормальная схема — репликация для отказоустойчивости + бэкапы для восстановления/отката.
'


